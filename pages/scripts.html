<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的脚本</title>
    <!-- 引入 PrismJS 基础样式 (用于语法高亮结构) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    
    <style>
        /* =========================================
           1. CSS 变量定义 (自适应明暗模式核心)
           ========================================= */
        :root {
            /* 白天模式 (默认) */
            --bg-body: #ffffff;
            --bg-card: #ffffff;
            --text-main: #000000;
            --text-muted: #666666;
            --border-color: #000000;
            --code-bg: #f4f4f4;
            --hover-bg: #e0e0e0;
            --scrollbar-thumb: #999;
            
            /* 语法高亮变量 (黑白风格) */
            --token-comment: #777;
            --token-string: #444;
            --token-keyword: #000;
            --token-weight: bold;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* 黑夜模式 */
                --bg-body: #121212;
                --bg-card: #000000;
                --text-main: #ffffff;
                --text-muted: #aaaaaa;
                --border-color: #ffffff;
                --code-bg: #1a1a1a;
                --hover-bg: #333333;
                --scrollbar-thumb: #666;

                /* 语法高亮变量 (黑白风格 - 反色) */
                --token-comment: #999;
                --token-string: #ccc;
                --token-keyword: #fff;
            }
        }

        /* =========================================
           2. 全局基础样式
           ========================================= */
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-weight: 900;
            letter-spacing: -1px;
            border-bottom: 4px solid var(--border-color);
            padding-bottom: 10px;
            display: inline-block;
            left: 50%;
            position: relative;
            transform: translateX(-50%);
        }

        /* =========================================
           3. 代码块卡片样式
           ========================================= */
        .code-card {
            border: 2px solid var(--border-color);
            background-color: var(--bg-card);
            margin-bottom: 30px;
            border-radius: 4px; /* 轻微圆角 */
            overflow: hidden;
            box-shadow: 4px 4px 0px var(--border-color); /* 复古硬阴影 */
            transition: transform 0.2s;
        }

        .code-card:hover {
            transform: translate(-1px, -1px);
            box-shadow: 5px 5px 0px var(--border-color);
        }

        /* --- 头部区域 (文件名、语言、按钮) --- */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 2px solid var(--border-color);
            background-color: var(--bg-card);
            user-select: none;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-family: "Courier New", Courier, monospace; /* 标题用等宽字体更有代码感 */
        }

        .lang-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            text-transform: uppercase;
            background: var(--bg-body);
        }

        .actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* --- 按钮样式 --- */
        .btn {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: var(--hover-bg);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* --- 代码内容区域 (包含折叠动画) --- */
        .card-content {
            background-color: var(--code-bg);
            max-height: none; /* 足够大的高度用于展开 */
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            position: relative;
        }

        /* 折叠状态 */
        .code-card.collapsed .card-content {
            max-height: 0;
            border-top: none;
        }
        
        /* 折叠时去掉头部的底边框，显得更整洁 */
        .code-card.collapsed .card-header {
            border-bottom: none;
            transition: border 0.4s; /* 延迟一点看起来更自然 */
        }
        .code-card:not(.collapsed) .card-header {
             border-bottom: 2px solid var(--border-color);
        }

        /* 箭头旋转动画 */
        .toggle-icon {
            transition: transform 0.3s;
        }
        .code-card.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        /* --- PrismJS 覆盖与滚动条优化 --- */
        pre {
            margin: 0 !important;
            padding: 20px !important;
            overflow-x: auto;
            /* 自定义滚动条 */
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) transparent;
        }

        /* Webkit 滚动条 */
        pre::-webkit-scrollbar {
            height: 8px;
        }
        pre::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        code {
            font-family: "Fira Code", Consolas, Monaco, "Andale Mono", monospace;
            font-size: 14px;
            text-shadow: none !important; /* 去掉Prism默认阴影 */
        }

        /* --- 强制黑白高亮样式 --- */
        /* 关键字粗体 */
        .token.keyword, .token.important, .token.bold {
            color: var(--token-keyword) !important;
            font-weight: var(--token-weight) !important;
            background: none !important;
        }
        /* 字符串 */
        .token.string, .token.char {
            color: var(--token-string) !important;
            background: none !important;
        }
        /* 注释 (斜体+灰色) */
        .token.comment, .token.prolog, .token.doctype, .token.cdata {
            color: var(--token-comment) !important;
            font-style: italic;
        }
        /* 数字、布尔值、常量 */
        .token.number, .token.boolean, .token.constant {
            color: var(--text-main) !important;
        }
        /* 函数名、类名 */
        .token.function, .token.class-name {
            color: var(--text-main) !important;
            text-decoration: underline; /* 用下划线区分函数 */
            text-decoration-color: var(--text-muted);
        }
        /* 标点符号 */
        .token.punctuation {
            color: var(--text-muted) !important;
        }
        /* 操作符 */
        .token.operator, .token.entity, .token.url {
            color: var(--text-main) !important;
            background: none !important;
        }
        
        /* 响应式调整 */
        @media (max-width: 600px) {
            body { padding: 10px; }
            .file-info span { 
                max-width: 120px; 
                overflow: hidden; 
                text-overflow: ellipsis; 
                white-space: nowrap; 
            }
            .btn span { display: none; } /* 手机端只显示图标 */
            .btn { padding: 6px; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>我的脚本</h1>

    <div class="code-card collapsed">
        <div class="card-header">
            <div class="file-info">
                <span class="lang-badge">JavaScript</span>
                <span>MiSans.js</span>
            </div>
            <div class="actions">
                <button class="btn copy-btn" title="Copy Code">
                    <!-- 复制图标 -->
                    <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                    <span>Copy</span>
                </button>
                <button class="btn toggle-btn" title="Toggle Code">
                    <!-- 折叠/展开图标 -->
                    <svg class="toggle-icon" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </button>
            </div>
        </div>
        <div class="card-content">
            <pre><code class="language-javascript">
// ==UserScript==
// @name         终极全局字体替换 (全字重+语言感知) - Merged v22 (Aggressive Latin Boost)
// @namespace    http://tampermonkey.net/
// @version      2025.11.21.aggressive-boost
// @description  [视觉平衡版] 针对 Latin 字符进行“二级加粗”(+2 Levels)，彻底解决中西文混排时西文显细的问题.同时严格保持原网页 CSS 字重数值，避免排版错乱.
// @author       Gemini Advanced (Optimized by User Request)
// @match        *://*/*
// @exclude      *://super.imyaigc.com/*
// @run-at       document-start
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // ======================
    // 1. 资源配置
    // ======================
    const CONFIG = {
        BASE_URL: 'https://cdn.jsdelivr.net/npm/misans@4.1.0/lib',
        MAPLE_MONO: 'https://cdn.jsdelivr.net/npm/@alphardex/maple-font@latest/dist/MapleMono-NF-Regular.woff2'
    };

    // 排除列表
    const EXCLUSIONS = {
        TAGS: new Set(['script', 'style', 'link', 'meta', 'noscript', 'svg', 'path', 'img', 'input', 'select', 'button', 'i', 'em', 'canvas', 'video', 'audio']),
        MONO_TAGS: new Set(['code', 'pre', 'kbd', 'samp', 'tt', 'var']),
        ICON_REGEX: /icon|fa-|fa\s|glyph|emoji|symbol|octicon|material-icons|codicon|rgsb|remixicon|fui-|qe-|ico/i
    };

    const processed = new WeakSet();

    const CSS_VARIABLES_TO_HIJACK = [
        '--font-family', '--font-sans', '--font-serif', '--font-mono',
        '--font-body', '--font-heading', '--font-display', '--font-base',
        '--bs-body-font-family', '--bs-font-sans-serif',
        '--chakra-fonts-body', '--chakra-fonts-heading',
        '--antd-font-family',
        '--mdc-typography-font-family',
        '--font-primary', '--font-secondary',
        '--el-font-family'
    ];

    // ======================
    // 2. 字体定义与映射逻辑
    // ======================

    // 浏览器标准的字重数值映射
    const WEIGHT_MAP = {
        'Thin': 100,
        'ExtraLight': 200,
        'Light': 300,
        'Regular': 400,
        'Medium': 500,
        'Demibold': 600,
        'Bold': 700,
        'Heavy': 900
    };

    /**
     * Latin 字符视觉补偿映射表 (激进版 +2 Levels)
     * 左侧：网页 CSS 要求的字重
     * 右侧：实际加载的 MiSans Latin 文件字重
     * 逻辑：英文必须要比中文用更粗的文件，才能在视觉上看起来一样粗.
     */
    const LATIN_FILE_MAPPING = {
        'Thin': 'Light',          // 100 -> 用 300 的文件
        'ExtraLight': 'Regular',  // 200 -> 用 400 的文件
        'Light': 'Medium',        // 300 -> 用 500 的文件
        'Regular': 'Demibold',    // [核心] 400 -> 用 600 的文件 (从 Medium 提升至 Demibold)
        'Medium': 'Bold',         // 500 -> 用 700 的文件
        'Demibold': 'Heavy',      // 600 -> 用 900 的文件
        'Bold': 'Heavy',          // 700 -> 用 900 的文件 (封顶)
        'Heavy': 'Heavy'          // 900 -> 保持 900
    };

    // 语种变种配置
    const VARIANTS = {
        'Normal':     { suffix: '',       name: 'MiSans',        type: 'css' },
        'TC':         { suffix: 'TC',     name: 'MiSans TC',     type: 'css' },
        'Latin':      { suffix: 'Latin',  name: 'MiSans Latin',  type: 'woff2' }, // 启用映射
        'Arabic':     { suffix: 'Arabic', name: 'MiSans Arabic', type: 'woff2' },
        'Thai':       { suffix: 'Thai',   name: 'MiSans Thai',   type: 'woff2' },
        'Tibetan':    { suffix: 'Tibetan',name: 'MiSans Tibetan',type: 'woff2' },
        'Myanmar':    { suffix: 'Myanmar',name: 'MiSans Myanmar',type: 'woff2' },
        'Lao':        { suffix: 'Lao',    name: 'MiSans Lao',    type: 'woff2' },
        'Khmer':      { suffix: 'Khmer',  name: 'MiSans Khmer',  type: 'woff2' },
        'Gurmukhi':   { suffix: 'Gurmukhi',name:'MiSans Gurmukhi',type:'woff2' },
        'Devanagari': { suffix: 'Devanagari',name:'MiSans Devanagari',type:'woff2' }
    };

    // ======================
    // 3. 字体栈构建
    // ======================

    const BASE_LATIN = `"MiSans Latin"`;
    const GLOBAL_FALLBACKS = `"MiSans Arabic", "MiSans Thai", "MiSans Tibetan", "MiSans Myanmar", "MiSans Lao", "MiSans Khmer", "MiSans Gurmukhi", "MiSans Devanagari", "MiSans TC", "MiSans", sans-serif`;

    function buildStack(primaryFont) {
        if (primaryFont === "MiSans") {
            return `${BASE_LATIN}, "MiSans", ${GLOBAL_FALLBACKS}`;
        }
        return `${BASE_LATIN}, "${primaryFont}", "MiSans", ${GLOBAL_FALLBACKS}`;
    }

    const STACKS = {
        sc: buildStack("MiSans"),
        tc: buildStack("MiSans TC"),
        ar: buildStack("MiSans Arabic"),
        th: buildStack("MiSans Thai"),
        my: buildStack("MiSans Myanmar"),
        lo: buildStack("MiSans Lao"),
        km: buildStack("MiSans Khmer"),
        gu: buildStack("MiSans Gurmukhi"),
        dev: buildStack("MiSans Devanagari"),
        tib: buildStack("MiSans Tibetan"),
        mono: `"Maple Mono", "Maple Mono NF", ${BASE_LATIN}, "MiSans", monospace`
    };

    // ======================
    // 4. FontLoader (加载逻辑)
    // ======================
    class FontLoader {
        constructor() {
            this.loaded = false;
        }

        loadFonts() {
            if (this.loaded) return;
            const style = document.createElement('style');
            style.id = 'nuclear-font-loader';
            let cssContent = '/* --- MiSans v22 (Aggressive Boost) --- */\n';

            // 1. 生成字体 @font-face
            Object.keys(VARIANTS).forEach(dirName => {
                const conf = VARIANTS[dirName];

                if (conf.type === 'css') {
                    Object.keys(WEIGHT_MAP).forEach(weightName => {
                        const filename = conf.suffix ? `MiSans${conf.suffix}-${weightName}.min.css` : `MiSans-${weightName}.min.css`;
                        cssContent += `@import url('${CONFIG.BASE_URL}/${dirName}/${filename}');\n`;
                    });
                } else {
                    Object.keys(WEIGHT_MAP).forEach(weightName => {
                        const cssWeightValue = WEIGHT_MAP[weightName]; // 400, 500, 700
                        let actualFileWeight = weightName; // Regular, Medium...

                        // [核心逻辑] Latin 文件替换
                        if (dirName === 'Latin' && LATIN_FILE_MAPPING[weightName]) {
                            actualFileWeight = LATIN_FILE_MAPPING[weightName];
                        }

                        const filename = `MiSans${conf.suffix}-${actualFileWeight}.woff2`;
                        const url = `${CONFIG.BASE_URL}/${dirName}/${filename}`;

                        cssContent += `
@font-face {
    font-family: '${conf.name}';
    src: url('${url}') format('woff2');
    font-weight: ${cssWeightValue}; /* 即使加载的是Demibold文件，也告诉浏览器这是400 */
    font-style: normal;
    font-display: swap;
}\n`;
                    });
                }
            });

            // 2. Maple Mono
            cssContent += `@font-face { font-family: 'Maple Mono'; src: url('${CONFIG.MAPLE_MONO}') format('woff2'); font-weight: normal; font-style: normal; font-display: swap; }\n`;

            // 3. 注入变量
            cssContent += `
:root, :host, body, html {
    --font-full-sc: ${STACKS.sc};
    --font-full-ar: ${STACKS.ar};
    ${CSS_VARIABLES_TO_HIJACK.map(v => `${v}: ${STACKS.sc} !important;`).join('\n    ')}
}

${Array.from(EXCLUSIONS.MONO_TAGS).join(', ')} {
    font-family: ${STACKS.mono} !important;
    font-variant-ligatures: normal !important;
}
`;
            style.textContent = cssContent;
            (document.head || document.documentElement).appendChild(style);
            this.loaded = true;
            console.log('[Font Engine] v22 Loaded. Latin Aggressively Boosted (+2 Levels).');
        }
    }

    // ======================
    // 5. 深度语言检测 (保持不变)
    // ======================
    const REGEX = {
        KR: /[\uAC00-\uD7A3]/,
        JP: /[\u3040-\u309F\u30A0-\u30FF]/,
        TH: /[\u0E00-\u0E7F]/,
        AR: /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]/,
        MY: /[\u1000-\u109F]/,
        KM: /[\u1780-\u17FF]/,
        LO: /[\u0E80-\u0EFF]/,
        DEV: /[\u0900-\u097F]/,
        GU: /[\u0A00-\u0A7F]/,
        TIB: /[\u0F00-\u0FFF]/
    };

    function detectLanguage(element) {
        const text = element.textContent?.substring(0, 500).trim();
        if (text) {
            if (REGEX.AR.test(text)) return 'ar';
            if (REGEX.TH.test(text)) return 'th';
            if (REGEX.MY.test(text)) return 'my';
            if (REGEX.KM.test(text)) return 'km';
            if (REGEX.LO.test(text)) return 'lo';
            if (REGEX.DEV.test(text)) return 'dev';
            if (REGEX.GU.test(text)) return 'gu';
            if (REGEX.TIB.test(text)) return 'tib';
        }
        const langAttr = element.closest('[lang]')?.lang?.toLowerCase();
        if (langAttr) {
            if (langAttr.includes('ar') || langAttr.includes('ur') || langAttr.includes('fa')) return 'ar';
            if (langAttr.includes('th')) return 'th';
            if (langAttr.includes('tw') || langAttr.includes('hk')) return 'tc';
        }
        return 'sc';
    }

    function processElement(el, forceUpdate = false) {
        if (processed.has(el) && !forceUpdate) return;

        const tag = el.tagName?.toLowerCase();
        if (!tag || EXCLUSIONS.TAGS.has(tag)) {
            processed.add(el);
            return;
        }

        const className = el.className;
        if (className && typeof className === 'string' && EXCLUSIONS.ICON_REGEX.test(className)) {
            processed.add(el);
            return;
        }

        const text = el.textContent?.trim();
        if (text && text.length <= 2) {
            const code = text.charCodeAt(0);
            if ((code >= 0xE000 && code <= 0xF8FF) || (code >= 0x2600 && code <= 0x27BF) || (code >= 0x1F000)) {
                processed.add(el);
                return;
            }
        }

        let targetFontStack = null;

        if (EXCLUSIONS.MONO_TAGS.has(tag)) {
            targetFontStack = STACKS.mono;
        } else {
            const lang = detectLanguage(el);
            targetFontStack = STACKS[lang] || STACKS.sc;
        }

        if (targetFontStack) {
            const currentStyle = el.style.getPropertyValue('font-family');
            if (forceUpdate || !currentStyle.includes('MiSans Latin')) {
                 el.style.setProperty('font-family', targetFontStack, 'important');
                 // 仅优化渲染
                 if (tag !== 'html') {
                     el.style.setProperty('text-rendering', 'optimizeLegibility', 'important');
                     el.style.setProperty('-webkit-font-smoothing', 'antialiased', 'important');
                 }
            }
        }
        processed.add(el);
    }

    // ======================
    // 6. 观察者系统
    // ======================
    function processNode(node) {
        if (node.nodeType !== 1) return;
        processElement(node);

        if (node.shadowRoot) {
            injectStylesIntoShadowRoot(node.shadowRoot);
            node.shadowRoot.querySelectorAll('*').forEach(el => processElement(el));
        }

        node.querySelectorAll('*').forEach(el => {
            processElement(el);
            if (el.shadowRoot) {
                 injectStylesIntoShadowRoot(el.shadowRoot);
                 el.shadowRoot.querySelectorAll('*').forEach(el => processElement(el));
            }
        });
    }

    function injectStylesIntoShadowRoot(shadowRoot) {
        if (!shadowRoot.getElementById('nuclear-font-loader')) {
            const style = document.getElementById('nuclear-font-loader');
            if (style) shadowRoot.appendChild(style.cloneNode(true));
        }
    }

    function processIframe(iframe) {
        try {
            const doc = iframe.contentDocument || iframe.contentWindow?.document;
            if (doc && !doc.__fontPatched) {
                doc.__fontPatched = true;
                const style = document.getElementById('nuclear-font-loader');
                if (style && doc.head) doc.head.appendChild(style.cloneNode(true));

                doc.querySelectorAll('*').forEach(el => processElement(el));

                const iframeObserver = new MutationObserver(mutations => {
                    for (const mutation of mutations) {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach(node => processNode(node));
                        } else if (mutation.type === 'attributes') {
                            processElement(mutation.target, true);
                        }
                    }
                });
                iframeObserver.observe(doc.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class', 'lang'] });
            }
        } catch (e) { }
    }

    function setupObserver() {
        const observer = new MutationObserver(mutations => {
            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                         if (node.nodeType !== 1) continue;
                        if (node.tagName === 'IFRAME') {
                            node.addEventListener('load', () => processIframe(node), { once: true });
                        } else {
                            processNode(node);
                        }
                    }
                } else if (mutation.type === 'attributes') {
                    const el = mutation.target;
                    if (processed.has(el) && (el.style.fontFamily.indexOf('MiSans Latin') === -1)) {
                        processElement(el, true);
                    }
                }
            }
        });

        observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['style', 'class', 'lang']
        });
    }

    const fontLoader = new FontLoader();
    function init() {
        fontLoader.loadFonts();
        processNode(document.documentElement);
        document.querySelectorAll('iframe').forEach(processIframe);
        setupObserver();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();
            </code></pre>
        </div>
    </div>

    <div class="code-card collapsed">
        <div class="card-header">
            <div class="file-info">
                <span class="lang-badge">JavaScript</span>
                <span>思源黑体.js</span>
            </div>
            <div class="actions">
                <button class="btn copy-btn" title="Copy Code">
                    <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                    <span>Copy</span>
                </button>
                <button class="btn toggle-btn" title="Toggle Code">
                    <svg class="toggle-icon" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </button>
            </div>
        </div>
        <div class="card-content">
            <pre><code class="language-javascript">
              // ==UserScript==
// @name         终极全局字体替换 (语言感知/JS核心/最终版) - 强制增强版
// @namespace    http://tampermonkey.net/
// @version      2025.11.15.lang-aware.enhanced
// @description  具备语言感知能力，自动为简/繁/日/韩文本匹配最佳字体.JS核心，强制注入，穿透Shadow DOM，兼容所有现代网站.此版本强制禁用网站自身字体.
// @author       Gemini Advanced (with user's guidance)
// @match        :///*
// @grant        none
// @run-at       document-start
// ==/UserScript==
(function () {
  code;
  Code;
  ("use strict");

  // ======================================================================

  // 1. CSS部分: 定义所有语言变体的字体栈

  // ======================================================================

  const cssDefinition = `

    /* 注入所有语言变体的网络字体 (如果本地没有) */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Sans+TC:wght@300;400;500;700&family=Noto+Sans+HK:wght@300;400;500;700&family=Noto+Sans+JP:wght@300;400;500;700&family=Noto+Sans+KR:wght@300;400;500;700&family=Noto+Serif+SC:wght@300;400;500;700&family=Noto+Serif+TC:wght@300;400;500;700&family=Noto+Serif+JP:wght@300;400;500;700&family=Noto+Serif+KR:wght@300;400;500;700&display=swap');



    @font-face {

        font-family: 'Maple Mono';

        src: local('Maple Mono NF'), local('Maple Mono'), url('https://cdn.jsdelivr.net/npm/@alphardex/maple-font@latest/dist/MapleMono-NF-Regular.woff2') format('woff2');

        font-weight: normal; font-style: normal;

    }



    :host, :root {

        /* 为每种语言定义独立的字体栈 */

        --font-sans-sc: 'Noto Sans SC', 'Source Han Sans CN', sans-serif;

        --font-sans-tc: 'Noto Sans TC', 'Source Han Sans TC', 'Noto Sans HK', sans-serif;

        --font-sans-jp: 'Noto Sans JP', 'Source Han Sans JP', sans-serif;

        --font-sans-kr: 'Noto Sans KR', 'Source Han Sans KR', sans-serif;



        --font-serif-sc: 'Noto Serif SC', 'Source Han Serif CN', serif;

        --font-serif-tc: 'Noto Serif TC', 'Source Han Serif TC', serif;

        --font-serif-jp: 'Noto Serif JP', 'Source Han Serif JP', serif;

        --font-serif-kr: 'Noto Serif KR', 'Source Han Serif KR', serif;



        --font-mono: 'Maple Mono', 'Sarasa Gothic SC', 'Fira Code', 'Menlo', 'Consolas', monospace;

    }

`;

  const styleElement = document.createElement("style");

  styleElement.textContent = cssDefinition;

  document.documentElement.appendChild(styleElement);

  // ======================================================================

  // 2. JavaScript部分: 语言感知与强制执行引擎 (此部分无需改动)

  // ======================================================================

  const processedElements = new WeakSet();

  const processedRoots = new WeakSet();

  // Unicode 特征检测正则表达式

  const KOREAN_REGEX = /[\uAC00-\uD7A3]/; // 韩文谚文

  const JAPANESE_REGEX = /[\u3040-\u309F\u30A0-\u30FF]/; // 日文平假名、片假名

  /**

 * 检测元素的语言 (lang属性优先，字符特征备用)

 * @param {HTMLElement} element

 * @returns {'sc'|'tc'|'jp'|'kr'}

 */

  function detectLanguage(element) {
    // 1. 语义检测: 检查 lang 属性

    const langAttr = element.closest("[lang]")?.lang.toLowerCase();

    if (langAttr) {
      if (langAttr.startsWith("zh-cn") || langAttr.startsWith("zh-sg"))
        return "sc";

      if (
        langAttr.startsWith("zh-tw") ||
        langAttr.startsWith("zh-hk") ||
        langAttr.startsWith("zh-hant")
      )
        return "tc";

      if (langAttr.startsWith("ja")) return "jp";

      if (langAttr.startsWith("ko")) return "kr";
    }

    // 2. 特征检测: 分析文本内容

    const text = element.textContent;

    if (text) {
      if (KOREAN_REGEX.test(text)) return "kr";

      if (JAPANESE_REGEX.test(text)) return "jp";
    }

    // 3. 默认/回退: 繁体中文(更广泛)或简体中文

    // 在无法明确判断时，默认使用简体中文作为基础

    return "sc";
  }

  const PROTECTED_TAGS = new Set([
    "i",
    "em",
    "svg",
    "path",
    "RGSb",
    "button",
    "script",
    "style",
    "link",
    "meta",
    "noscript",
  ]);

  const CODE_TAGS = new Set(["pre", "code", "kbd", "samp"]);

  const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);

  const ICON_CLASS_REGEX = /icon|fa-|fa\s|glyph|emoji|symbol|octicon/i;

  function forceStyleOnElement(element) {
    if (!element?.style || processedElements.has(element)) return;

    const tagName = element.tagName.toLowerCase();

    if (
      PROTECTED_TAGS.has(tagName) ||
      ICON_CLASS_REGEX.test(element.className)
    ) {
      processedElements.add(element);
      return;
    }

    const style = getComputedStyle(element);

    let targetFontFamily = null;

    if (CODE_TAGS.has(tagName)) {
      targetFontFamily = style.getPropertyValue("--font-mono").trim();
    } else {
      const lang = detectLanguage(element);

      const isHeading = HEADING_TAGS.has(tagName);

      const fontType = isHeading ? "serif" : "sans";

      // 根据语言和类型，动态构建并获取对应的CSS变量

      const variableName = `--font-${fontType}-${lang}`;

      targetFontFamily = style.getPropertyValue(variableName).trim();
    }

    if (targetFontFamily && element.style.fontFamily !== targetFontFamily) {
      element.style.setProperty("font-family", targetFontFamily, "important");
    }

    processedElements.add(element);
  }

  function traverseAndApply(rootNode) {
    if (!rootNode || processedRoots.has(rootNode)) return;

    if (rootNode instanceof ShadowRoot) {
      const style = document.createElement("style");

      style.textContent = cssDefinition;

      rootNode.appendChild(style);
    }

    processedRoots.add(rootNode);

    rootNode.querySelectorAll("*").forEach((el) => {
      forceStyleOnElement(el);

      if (el.shadowRoot) {
        traverseAndApply(el.shadowRoot);
      }
    });
  }

  // ======================================================================

  // 3. 执行与监听 (此部分无需改动)

  // ======================================================================

  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          traverseAndApply(node);
        }
      }
    }
  });

  observer.observe(document.documentElement, {
    childList: true,

    subtree: true,
  });

  // 初始执行，确保页面加载时静态内容被处理

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () =>
      traverseAndApply(document.body)
    );
  } else {
    traverseAndApply(document.body);
  }
})();
            </code></pre>
        </div>
    </div>

    <div class="code-card collapsed">
        <div class="card-header">
            <div class="file-info">
                <span class="lang-badge">JavaScript</span>
                <span>苹方字体.js</span>
            </div>
            <div class="actions">
                <button class="btn copy-btn" title="Copy Code">
                    <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                    <span>Copy</span>
                </button>
                <button class="btn toggle-btn" title="Toggle Code">
                    <svg class="toggle-icon" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </button>
            </div>
        </div>
        <div class="card-content">
            <pre><code class="language-javascript">
// ==UserScript==
// @name Universal Font Replacement v13.3 - (v9.7 Font Injection) - [Modified v4-MapleMono]
// @namespace http://tampermonkey.net/
// @version 7.0
// @description v13.3穿透 + v9.7字体注入：Inter -> PingFang (SC,TC,HK) -> Noto (CJK) | 代码: Maple Mono -> Noto Mono
// @match *://*/*
// @exclude *://super.imyaigc.com/*
// @run-at document-start
// @grant none
// ==/UserScript==

(function () {
  "use strict";

  // ======================
  // 配置
  // ======================
  const PROTECTED_TAGS = new Set([
    "script",
    "style",
    "link",
    "meta",
    "noscript",
    "svg",
    "path",
  ]);
  const CODE_TAGS = new Set(["code", "pre", "kbd", "samp", "tt"]);
  const processed = new WeakSet();

  // 字体栈配置 (来自v13.3)
  // [MODIFIED v3] 完整实现 Inter -> PingFang (SC/TC/HK) -> Noto (CJK) 栈
  const UNIFIED_STACK =
    'Inter, "PingFang SC", "PingFang TC", "PingFang HK", "Noto Sans SC", "Noto Sans TC", "Noto Sans HK", "Noto Sans JP", "Noto Sans KR"';

  // [MODIFIED v4] 遵照用户要求：代码字体使用 Maple Mono -> Noto Sans Mono (思源等宽)
  const MONO_STACK = '"Maple Mono", "Noto Sans Mono", "SF Mono"';

  const FONTS = {
    latin: UNIFIED_STACK,
    cjk: UNIFIED_STACK,
    mixed: UNIFIED_STACK,
    mono: MONO_STACK, // <--- MODIFIED
  };

  // CDN配置 (来自v9.7)
  const CONFIG = {
    CDN: {
      PINGFANG: "https://cdn.jsdelivr.net/gh/ZWolken/PingFang/",
      GOOGLE_FONTS: "https://fonts.googleapis.com/css2",
    },
  };

  // ======================
  // FontLoader（来自v9.7 - 字体注入系统）
  // ======================
  class FontLoader {
    constructor() {
      this.loaded = false;
    }

    loadFonts() {
      if (this.loaded) return;
      const style = document.createElement("style");
      style.id = "font-replacement-loader";

      // [INFO] Noto Sans 字体在这里被 @import
      style.textContent = `
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Inter:wght@100..900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Roboto:wght@100;300;400;500;700;900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Open+Sans:wght@300..800&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Lato:wght@100;300;400;700;900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+SC:wght@100..900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+TC:wght@100..900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+HK:wght@100..900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+JP:wght@100..900&display=swap');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+KR:wght@100..900&display=swap');

/* [MODIFIED v4] 注入 Maple Mono 和 Noto Sans Mono (思源等宽) */
@import url('https://cdn.jsdelivr.net/npm/maple-mono/maple.css');
@import url('${
        CONFIG.CDN.GOOGLE_FONTS
      }?family=Noto+Sans+Mono:wght@100..900&display=swap');

${this.generatePingFangFontFaces()}
`;
      (document.head || document.documentElement).appendChild(style);
      this.loaded = true;
    }

    generatePingFangFontFaces() {
      // [INFO] PingFang SC, TC, HK 字体在这里被 @font-face 注入
      const variants = ["SC", "TC", "HK"];
      const weights = [
        { name: "Thin", weight: 100 },
        { name: "Ultralight", weight: 200 },
        { name: "Light", weight: 300 },
        { name: "Regular", weight: 400 },
        { name: "Medium", weight: 500 },
        { name: "Semibold", weight: 600 },
        { name: "Semibold", weight: 700 },
        { name: "Heavy", weight: 800 },
        { name: "Heavy", weight: 900 },
      ];
      const cjkUnicodeRange =
        "U+2E80-2EFF, U+3000-303F, U+3040-309F, U+30A0-30FF, U+3100-312F, U+3130-318F, U+3190-319F, U+31A0-31BF, U+31C0-31EF, U+31F0-31FF, U+3200-32FF, U+3300-33FF, U+3400-4DBF, U+4DC0-4DFF, U+4E00-9FFF, U+A000-A48F, U+A490-A4CF, U+AC00-D7AF, U+F900-FAFF, U+FE30-FE4F, U+FF00-FFEF, U+20000-2A6DF, U+2A700-2B73F, U+2B740-2B81F, U+2B820-2CEAF, U+2CEB0-2EBEF, U+30000-3134F";
      let css = "";
      variants.forEach((variant) => {
        weights.forEach((style) => {
          css += `
@font-face {
    font-family: 'PingFang ${variant}';
    src: url('${CONFIG.CDN.PINGFANG}PingFang${variant}-${style.name}.otf') format('opentype');
    font-weight: ${style.weight};
    font-style: normal;
    font-display: swap;
    unicode-range: ${cjkUnicodeRange};
}
`;
        });
      });
      return css;
    }
  }

  // ======================
  // 快速文本类型检测（保留，但逻辑中已不再依赖其区分cjk/latin）
  // ======================
  function getTextType(text) {
    if (!text || text.length === 0) return "empty";
    const sample = text.substring(0, 30);
    const hasLatin = /[a-zA-Z]/.test(sample);
    const hasCJK =
      /[\u4e00-\u9fff\u3000-\u303f\u3040-\u309f\u30a0-\u30ff]/.test(sample);

    if (!hasLatin && !hasCJK) return "empty";
    if (hasLatin && !hasCJK) return "latin";
    if (!hasLatin && hasCJK) return "cjk";

    const latinCount = (sample.match(/[a-zA-Z]/g) || []).length;
    const cjkCount = (sample.match(/[\u4e00-\u9fff]/g) || []).length;
    if (cjkCount < latinCount * 0.3) return "latin";

    return "mixed";
  }

  // ======================
  // 处理元素（核心函数）
  // ======================
  function processElement(el) {
    if (processed.has(el)) return;

    const tag = el.tagName?.toLowerCase();
    if (!tag || PROTECTED_TAGS.has(tag)) {
      processed.add(el);
      return;
    }

    if (tag === "i") {
      processed.add(el);
      return;
    }

    const className = el.className;
    if (className && typeof className === "string") {
      if (/icon|fa-|fa\s|glyph|emoji|symbol/i.test(className)) {
        processed.add(el);
        return;
      }
    }

    const text = el.textContent?.trim();
    if (text && text.length <= 2) {
      const code = text.charCodeAt(0);
      if (
        (code >= 0xe000 && code <= 0xf8ff) ||
        (code >= 0x2600 && code <= 0x27bf) ||
        code >= 0x1f000
      ) {
        processed.add(el);
        return;
      }
    }

    // 确定字体类型
    let fontStack;

    // [INFO] 统一使用 FONTS.mixed (指向 UNIFIED_STACK)
    if (CODE_TAGS.has(tag)) {
      fontStack = FONTS.mono; // <--- MODIFIED: 将使用新的 MONO_STACK
    } else {
      fontStack = FONTS.mixed;
    }

    // 直接应用样式
    if (fontStack) {
      // [INFO] 保留 !important 强制覆盖
      el.style.setProperty("font-family", fontStack, "important");
      el.style.setProperty("text-rendering", "optimizeLegibility", "important");
      el.style.setProperty(
        "-webkit-font-smoothing",
        "antialiased",
        "important"
      );
    }
    processed.add(el);
  }

  // ======================
  // 处理所有元素
  // ======================
  function processAll() {
    const elements = document.getElementsByTagName("*");
    for (let i = 0; i < elements.length; i++) {
      processElement(elements[i]);
    }
    processShadowRoots();
  }

  // ======================
  // 处理Shadow DOM
  // ======================
  function processShadowRoots() {
    const elements = document.querySelectorAll("*");
    for (let el of elements) {
      if (el.shadowRoot) {
        const shadowElements = el.shadowRoot.querySelectorAll("*");
        for (let shadowEl of shadowElements) {
          processElement(shadowEl);
        }
      }
    }
  }

  // ======================
  // MutationObserver
  // ======================
  function setupObserver() {
    let pending = [];
    let scheduled = false;

    const processPending = () => {
      scheduled = false;
      processShadowRoots();
      for (let el of pending) {
        processElement(el);
      }
      pending = [];
    };

    const observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        if (mutation.addedNodes.length) {
          for (let node of mutation.addedNodes) {
            if (node.nodeType === 1) {
              pending.push(node);
              const children = node.getElementsByTagName?.("*");
              if (children) {
                for (let child of children) {
                  pending.push(child);
                }
              }
            }
          }
        }
      }

      if (pending.length && !scheduled) {
        scheduled = true;
        if (window.requestIdleCallback) {
          requestIdleCallback(processPending, { timeout: 50 });
        } else {
          setTimeout(processPending, 0);
        }
      }
    });

    observer.observe(document.documentElement, {
      childList: true,
      subtree: true,
    });
  }

  // ======================
  // 初始化
  // ======================
  const fontLoader = new FontLoader();

  function init() {
    fontLoader.loadFonts();
    processAll();
    setupObserver();

    setInterval(processAll, 5000);

    setInterval(() => {
      const iframes = document.querySelectorAll("iframe");
      for (let iframe of iframes) {
        try {
          const doc = iframe.contentDocument || iframe.contentWindow?.document;
          if (doc && !doc.__fontPatched) {
            doc.__fontPatched = true;
            const elements = doc.getElementsByTagName("*");
            for (let el of elements) {
              processElement(el);
            }
          }
        } catch (e) {
          // 跨域
        }
      }
    }, 3000);
  }

  if (document.body || document.documentElement) {
    init();
  } else {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init);
    } else {
      init();
    }
  }

  window.__fontEngine = {
    processAll: processAll,
    processElement: processElement,
    reload: () => {
      processed.clear();
      processAll();
    },
  };

  console.log(
    "[Font v13.3.4-Modified] Initialized with full font stack (Inter -> PingFang -> Noto) and Code (Maple -> Noto Mono)."
  );
})();
            </code></pre>
        </div>
    </div>

</div>

<!-- 引入 PrismJS 脚本 (用于解析语法) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<!-- 按需引入更多语言包，例如 prism-java.min.js 等 -->

<script>
    document.addEventListener('DOMContentLoaded', () => {
        
        // 1. 处理折叠/展开逻辑
        const toggleBtns = document.querySelectorAll('.toggle-btn');
        
        toggleBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const card = this.closest('.code-card');
                card.classList.toggle('collapsed');
            });
        });

        // 2. 处理一键复制逻辑
        const copyBtns = document.querySelectorAll('.copy-btn');

        copyBtns.forEach(btn => {
            btn.addEventListener('click', async function() {
                const card = this.closest('.code-card');
                const codeElement = card.querySelector('code');
                const originalText = this.querySelector('span').innerText;
                
                if (!codeElement) return;

                try {
                    // 执行复制
                    await navigator.clipboard.writeText(codeElement.innerText);
                    
                    // 更改按钮状态
                    this.querySelector('span').innerText = 'Copied!';
                    this.style.color = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? '#fff' : '#000';
                    
                    // 2秒后恢复
                    setTimeout(() => {
                        this.querySelector('span').innerText = originalText;
                        this.style.color = '';
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    this.querySelector('span').innerText = 'Error';
                }
            });
        });
    });
</script>

</body>
</html>
